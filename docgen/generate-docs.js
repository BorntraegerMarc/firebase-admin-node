/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { exec } = require('child-process-promise');
const fs = require('mz/fs');
const jsdom = require('jsdom');
const path = require('path');
const readline = require('readline');
const yargs = require('yargs');
const yaml = require('js-yaml');

const repoPath = path.resolve(`${__dirname}/..`);

// The following files do not belong in any namespace, for example:
// https://firebase.google.com/docs/reference/admin/node/TopicMessage
const noNamespace = [
  'topicmessage.html',
  'tokenmessage.html',
  'conditionmessage.html'
];

// We determine if auto-type generation is turned on, and provide per-service
// paths to TypeDoc (as nested wildcard /lib/**/*.d.ts does not work).
// Note: The d.ts files need to be generated beforehand, using `npm run build`
// in order to refresh the typings. This is not needed normally because the 
// src files would be inspected instead of lib.
const autoGeneratedTypingsEnabled = process.env.TYPE_GENERATION_MODE === 'auto';
const generatedFiles = [
  `${repoPath}/lib/*.d.ts`,
  `${repoPath}/lib/database/*.d.ts`,
  `${repoPath}/lib/firestore/*.d.ts`,
  `${repoPath}/lib/instance-id/*.d.ts`,
  `${repoPath}/lib/messaging/*.d.ts`,
  `${repoPath}/lib/project-management/*.d.ts`,
  `${repoPath}/lib/remote-config/*.d.ts`,
  `${repoPath}/lib/security-rules/*.d.ts`,
];
let filenameIndex = {}; // global filenameIndex, used to remap files and links

const defaultFiles = autoGeneratedTypingsEnabled ?
  generatedFiles.join(' ') : `${repoPath}/src/*.d.ts`;

// Command-line options.
const { source: sourceFile } = yargs
  .option('source', {
    default: defaultFiles,
    describe: 'Typescript source file(s)',
    type: 'string'
  })
  .version(false)
  .help().argv;

const docPath = path.resolve(`${__dirname}/html/node`);
const contentPath = path.resolve(`${__dirname}/content-sources/node`);
const tempHomePath = path.resolve(`${contentPath}/HOME_TEMP.md`);
const devsitePath = `/docs/reference/admin/node/`;

// Custom logic for 3rd party re-exported packages.
const firestoreExcludes = ['v1', 'v1beta1', 'setLogFunction','DocumentData'];
const databaseExcludes = ['enableLogging', 'EventType'];

const firestoreHtmlPath = `${docPath}/admin.firestore.html`;
const databaseHtmlPath = `${docPath}/admin.database.html`;
const thirdPartyFooter = '\n  </ul>\n</section>\n';

function generateThirdPartyHeader(packageName) {
  return `<section class="tsd-panel-group tsd-member-group ">
  <h2>Type aliases</h2>
  <div class="tsd-panel">
    <p>Following types are defined in the <code>${packageName}</code> package
    and re-exported from this namespace for convenience.</p>
  </div>
  <ul>`;
}

/**
 * Strips path prefix and returns only filename.
 * @param {string} path
 */
function stripPath(path) {
  const parts = path.split('/');
  return parts[parts.length - 1];
}

/**
 * Generates an index of filename to service name mappings used to infer
 * the namespace of an exported type. This is determined based on the
 * toc.yaml file. For example:
 * {
 *   "androidconfig.html": "messaging",
 *   "androidfcmoptions.html": "messaging",
 *   ...
 *   "explicitparametervalue.html": "remote-config",
 *   ...
 * }
 * If the same typename is exported across two namespaces an error is logged,
 * excluding RTDB/firestore query we simply provide links to external docs.
 */
function generateFilenameIndex() {
  if (!autoGeneratedTypingsEnabled) {
    return;
  }

  const tocContents = fs.readFileSync(`${contentPath}/toc.yaml`, 'utf8');
  const { toc } = yaml.safeLoad(tocContents);

  toc.forEach(group => {
    const section = group.section || [];
    section.forEach(item => {      
      // Ex: /docs/reference/admin/node/admin.remoteConfig.RemoteConfig
      //                                      ^----------^ ^----------^
      //                                       serviceName   typeName  
      const filename = item.path.split('/').pop().split('.');

      // For example, admin.admin does not have a serviceName
      if (filename !== undefined && filename.length == 3) {
        const serviceName = filename[1];
        const typeName = `${filename[2].toLowerCase()}.html`;

        // Both RTDB and Firestore export query, but we only export aliases
        if (filenameIndex[typeName] !== undefined && typeName !== 'query.html') {
          console.log(`ERROR ${typeName}:${serviceName} is defined in two namespaces!`);
        } else {
          filenameIndex[typeName] = serviceName;
        }
      }
    });
  });
}

/**
 * Runs Typedoc command.
 *
 * Additional config options come from ./typedoc.js
 */
function runTypedoc() {
  const command = `${repoPath}/node_modules/.bin/typedoc ${sourceFile} \
  --excludePrivate \
  --out ${docPath} \
  --readme ${tempHomePath} \
  --options ${__dirname}/typedoc.js \
  --theme ${__dirname}/theme`;

  console.log('Running command:\n', command);
  return exec(command);
}

/**
 * Moves files from subdir to root.
 * @param {string} subdir Subdir to move files out of.
 */
function moveFilesToRoot(subdir) {
  return exec(`mv ${docPath}/${subdir}/* ${docPath}`)
    .then(() => {
      exec(`rmdir ${docPath}/${subdir}`);
    })
    .catch(e => console.error(e));
}

/**
 * Reformat links to match flat structure.
 * @param {string} file File to fix links in.
 */
function fixLinks(file) {
  return fs.readFile(file, 'utf8').then(data => {
    const flattenedLinks = data
      .replace(/\.\.\//g, '')
      .replace(/(modules|interfaces|classes|enums)\//g, '');
    let caseFixedLinks = flattenedLinks;

    // Fix filenames by leveraging the filenameIndex
    // For example: <a href="androidnotification.html#bodylocargs"
    // Becomes:     <a href="admin.messaging.androidNotification.html#bodylocargs"
    if (autoGeneratedTypingsEnabled) {
      const re = /<a href="([^"]*?\.html)(#[^"]*?)?"/g;
      let results;
      do {
        results = re.exec(caseFixedLinks);
        if (results) {
          const serviceName = filenameIndex[results[1]];
          
          if (results[1].indexOf('admin') !== -1
              || results[1].indexOf('http') !== -1
              || noNamespace.includes(results[1])) {
            continue;
          }

          if (serviceName === undefined) {
            console.log(`ERROR Unknown file ${results[1]} from ${results[0]} in ${file}`);
          } else {
            caseFixedLinks = caseFixedLinks.replace(
              results[0],
              `<a href="admin.${serviceName.toLowerCase()}.${results[1]}${results[2] === undefined ? '' : results[2]}"`
            );
          }
        }
      } while (results);

      // Remove "Implements: any"
      const implementsAnyRe = /<section class="tsd-panel">(\r\n|\r|\n)(\s)*<h3>Implements<\/h3>(.|\r\n|\r|\n)*?<\/section>/g;
      caseFixedLinks = caseFixedLinks.replace(implementsAnyRe, '');

      // Replace Accessors with Properties
      const accessorsMedium = /<h3>Accessors<\/h3>/g;
      caseFixedLinks = caseFixedLinks.replace(accessorsMedium, '<h3>Properties</h3>');

      // Replace Accessors with Properties
      const accessorsLarge = /<h2>Accessors<\/h2>/g;
      caseFixedLinks = caseFixedLinks.replace(accessorsLarge, '<h2>Properties</h2>');

      // Replace FirebaseApp with _admin.app.App
      const firebaseAppTagContents = />FirebaseApp<\//g;
      caseFixedLinks = caseFixedLinks.replace(firebaseAppTagContents, '>_admin.app.App<\/');

      // Remove the "GET" tag from Accessors
      const accessorGet = /<span class="tsd-signature-symbol">get<\/span>/g;
      caseFixedLinks = caseFixedLinks.replace(accessorGet, '');
    }

    for (const lower in lowerToUpperLookup) {
      const re = new RegExp(lower, 'g');
      caseFixedLinks = caseFixedLinks.replace(re, lowerToUpperLookup[lower]);
    }

    return fs.writeFile(file, caseFixedLinks);
  });
}

let tocText = '';

/**
 * Generates temporary markdown file that will be sourced by Typedoc to
 * create index.html.
 *
 * @param {string} tocRaw
 * @param {string} homeRaw
 */
function generateTempHomeMdFile(tocRaw, homeRaw) {
  const { toc } = yaml.safeLoad(tocRaw);
  let tocPageLines = [homeRaw, '# API Reference'];
  toc.forEach(group => {
    tocPageLines.push(`\n## [${group.title}](${stripPath(group.path)}.html)`);
    // We ignore the contents in toc.yaml for admin.database because we will
    // simply redirect the user to the JS SDK RTDB documentation
    if (autoGeneratedTypingsEnabled && group.title !== 'admin.database') {
      const section = group.section || [];
      section.forEach(item => {
        tocPageLines.push(`- [${item.title}](${stripPath(item.path)}.html)`);
      });
    }
  });
  return fs.writeFile(tempHomePath, tocPageLines.join('\n'));
}

/**
 * Mapping between lowercase file name and correctly cased name.
 * Used to update links when filenames are capitalized.
 */
const lowerToUpperLookup = {};

/**
 * Checks to see if any files listed in toc.yaml were not generated.
 * If files exist, fixes filename case to match toc.yaml version.
 */
function checkForMissingFilesAndFixFilenameCase() {
  // Get filenames from toc.yaml.
  const filenames = tocText
    .split('\n')
    .filter(line => line.includes('path:'))
    .map(line => line.split(devsitePath)[1]);
  // Logs warning to console if a file from TOC is not found.
  const fileCheckPromises = filenames.map(filename => {
    // Warns if file does not exist, fixes filename case if it does.
    // Preferred filename for devsite should be capitalized and taken from
    // toc.yaml.
    const tocFilePath = `${docPath}/${filename}.html`;
    // Generated filename from Typedoc will be lowercase.
    const generatedFilePath = `${docPath}/${filename.toLowerCase()}.html`;
    return fs.exists(generatedFilePath).then(exists => {
      if (exists) {
        // Store in a lookup table for link fixing.
        lowerToUpperLookup[
          `${filename.toLowerCase()}.html`
        ] = `${filename}.html`;
        return fs.rename(generatedFilePath, tocFilePath);
      } else {
        console.warn(
          `Missing file: ${filename}.html requested ` +
            `in toc.yaml but not found in ${docPath}`
        );
      }
    });
  });
  return Promise.all(fileCheckPromises).then(() => filenames);
}

/**
 * Gets a list of html files in generated dir and checks if any are not
 * found in toc.yaml.
 * Option to remove the file if not found (used for node docs).
 *
 * @param {Array} filenamesFromToc Filenames pulled from toc.yaml
 * @param {boolean} shouldRemove Should just remove the file
 */
function checkForUnlistedFiles(filenamesFromToc, shouldRemove) {
  return fs.readdir(docPath).then(files => {
    const htmlFiles = files
      .filter(filename => filename.slice(-4) === 'html')
      .map(filename => filename.slice(0, -5));
    const removePromises = [];
    htmlFiles.forEach(filename => {
      if (
        !filenamesFromToc.includes(filename) &&
        filename !== 'index' &&
        filename !== 'globals'
      ) {
        if (shouldRemove) {
          console.log(
            `REMOVING ${docPath}/${filename}.html - not listed in toc.yaml.`
          );
          removePromises.push(fs.unlink(`${docPath}/${filename}.html`));
        } else {
          // This is just a warning, it doesn't need to finish before
          // the process continues.
          console.warn(
            `Unlisted file: ${filename} generated ` +
              `but not listed in toc.yaml.`
          );
        }
      }
    });
    if (shouldRemove) {
      return Promise.all(removePromises).then(() =>
        htmlFiles.filter(filename => filenamesFromToc.includes(filename))
      );
    } else {
      return htmlFiles;
    }
  });
}

/**
 * Writes a _toc_autogenerated.yaml as a record of all files that were
 * autogenerated.  Helpful to tech writers.
 *
 * @param {Array} htmlFiles List of html files found in generated dir.
 */
function writeGeneratedFileList(htmlFiles) {
  const fileList = htmlFiles.map(filename => {
    return {
      title: filename,
      path: `${devsitePath}${filename}`
    };
  });
  const generatedTocYAML = yaml.safeDump({ toc: fileList });
  return fs
    .writeFile(`${docPath}/_toc_autogenerated.yaml`, generatedTocYAML)
    .then(() => htmlFiles);
}

/**
 * Fix all links in generated files to other generated files to point to top
 * level of generated docs dir.
 *
 * @param {Array} htmlFiles List of html files found in generated dir.
 */
function fixAllLinks(htmlFiles) {
  const writePromises = [];
  htmlFiles.forEach(file => {
    // Update links in each html file to match flattened file structure.
    writePromises.push(fixLinks(`${docPath}/${file}.html`));
  });
  return Promise.all(writePromises);
}

/**
 * Updates the auto-generated 3rd party module API references page,
 * by appending the specified HTML content block.
 *
 * @param {string} contentBlock The HTML content block to be added to the
 * body of the docs.
 */
function updateThirdPartyModuleBodyHtml(contentBlock, filePath) {
  const dom = new jsdom.JSDOM(fs.readFileSync(filePath));
  const contentNode = dom.window.document.body.querySelector('.col-12');

  const newSection = new jsdom.JSDOM(contentBlock);
  contentNode.appendChild(newSection.window.document.body.firstChild);
  fs.writeFileSync(filePath, dom.window.document.documentElement.outerHTML);
}

/**
 * Removes all top-level content from the web-page, where top-level content
 * is defined as the different sections such as "Index", "Variables", etc.
 * 
 * @param {string} filePath The file to remove all top-level content from.
 */
function removeAllNonTopLevelContent(filePath) {
  const dom = new jsdom.JSDOM(fs.readFileSync(filePath));
  const contentNode = dom.window.document.body.querySelector('.col-12');

  while (contentNode.children.length >= 2) {
    contentNode.removeChild(contentNode.children[1]);
  }

  fs.writeFileSync(filePath, dom.window.document.documentElement.outerHTML);
}

/**
 * Adds third-party type aliases to the auto-generated API docs. These are the
 * types that are imported from another package, and then re-exported from the
 * an admin.* namespace. TypeDoc currently does not handle these correctly, so
 * we need this solution instead.
 */
function addThirdPartyTypeAliases(header, footer, filePath, moduleName, baseUrl, blacklist) {
  return new Promise((resolve, reject) => {
    const fileStream = fs.createReadStream(`${repoPath}/src/index.d.ts`);
    fileStream.on('error', (err) => {
      reject(err);
    });
    const lineReader = readline.createInterface({
      input: fileStream,
    });

    let contentBlock = header;
    lineReader.on('line', (line) => {
      line = line.trim();
      if (line.startsWith('export import') && line.indexOf(moduleName) >= 0) {
        const typeName = line.split(' ')[2];
        if (blacklist.indexOf(typeName) === -1) {
          contentBlock += `
          <li>
            <a href="${baseUrl}${typeName}.html">${typeName}</a>
          </li>`;
        }
      }
    });

    lineReader.on('close', () => {
      try {
        contentBlock += footer;
        updateThirdPartyModuleBodyHtml(contentBlock, filePath);
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  });
}

function addPageTitleNamespace() {
  fs.readdirSync(docPath).forEach(file => {
    const indexedFilename = file.toLowerCase().substr(file.lastIndexOf('.', file.lastIndexOf('.') - 1) + 1);
    const namespace = filenameIndex[indexedFilename];
    
    if (file.indexOf('.html') !== -1) {
      const dom = new jsdom.JSDOM(fs.readFileSync(`${docPath}/${file}`));
      const contentNode = dom.window.document.body.querySelector('.tsd-breadcrumb');
      if (contentNode !== null && contentNode.children.length < 2) {
        if (namespace !== undefined) {
          const namespaceBreadcrumb = dom.window.document.createElement('div');
          namespaceBreadcrumb.style = 'display:inline';
          namespaceBreadcrumb.innerHTML = `<li class="breadcrumb-name">
          <small><a href="admin.${namespace}.html">${namespace}</a>.</small>
          </li>`;

          contentNode.prepend(namespaceBreadcrumb);
        }
        const adminBreadcrumb = dom.window.document.createElement('div');
        adminBreadcrumb.style = 'display:inline';
        adminBreadcrumb.innerHTML = `<li class="breadcrumb-name">
        <small><a href="admin.html">admin</a>.</small>
        </li>`;

        contentNode.prepend(adminBreadcrumb);
      }

      const variablesNode = dom.window.document.body.querySelector('.tsd-member-group');
      if (variablesNode !== null) {
        if (variablesNode.children[0].nodeName === 'H2' && variablesNode.children[0].innerHTML === 'Variables') {
          variablesNode.remove();
        }
      }
      fs.writeFileSync(`${docPath}/${file}`, dom.window.document.documentElement.outerHTML);
    }
  });
}

function renameUnmappedFiles() {
  if (!autoGeneratedTypingsEnabled) {
    return;
  }

  fs.readdirSync(docPath).forEach(filename => {
    if (filename !== 'interfaces' && !fs.lstatSync(`${docPath}/${filename}`).isDirectory() 
        && filename.indexOf('admin') === -1
        && !noNamespace.includes(filename)) {
      const serviceName = filenameIndex[filename];
      if (serviceName === undefined) {
        console.log(`ERROR Could not find a service for ${filename}`);
      } else {
        fs.renameSync(`${docPath}/${filename}`, `${docPath}/admin.${serviceName}.${filename}`);
      }
    }
  });
}

/**
 * Main document generation process.
 *
 * Steps for generating documentation:
 * 1) Create temporary md file as source of homepage.
 * 2) Run Typedoc, sourcing index.d.ts for API content and temporary md file
 *    for index.html content.
 * 3) Write table of contents file.
 * 4) Flatten file structure by moving all items up to root dir and fixing
 *    links as needed.
 * 5) Check for mismatches between TOC list and generated file list.
 */
Promise.all([
  fs.readFile(`${contentPath}/toc.yaml`, 'utf8'),
  fs.readFile(`${contentPath}/HOME.md`, 'utf8')
])
  // Read TOC and homepage text and assemble a homepage markdown file.
  // This file will be sourced by Typedoc to generate index.html.
  .then(([tocRaw, homeRaw]) => {
    tocText = tocRaw;
    return generateTempHomeMdFile(tocRaw, homeRaw);
  })
  // Run main Typedoc process (uses index.d.ts and generated temp file above).
  .then(runTypedoc)
  .then(output => {
    // Typedoc output.
    console.log(output.stdout);
    // Clean up temp home markdown file. (Nothing needs to wait for this.)
    return fs.unlink(tempHomePath);
  })
  // Write out TOC file.  Do this after Typedoc step to prevent Typedoc
  // erroring when it finds an unexpected file in the target dir.
  .then(() => fs.writeFile(`${docPath}/_toc.yaml`, tocText))
  // Flatten file structure. These categories don't matter to us and it makes
  // it easier to manage the docs directory.
  .then(() => {
    return Promise.all([
      moveFilesToRoot('classes'),
      moveFilesToRoot('modules'),
      moveFilesToRoot('interfaces'),
      moveFilesToRoot('enums'),
    ]);
  })
  .then(() => generateFilenameIndex())
  .then(() => renameUnmappedFiles())
  // Check for files listed in TOC that are missing and warn if so.
  // Not blocking.
  .then(checkForMissingFilesAndFixFilenameCase)
  // Check for files that exist but aren't listed in the TOC and warn.
  // (If API is node, actually remove the file.)
  // Removal is blocking, warnings aren't.
  .then(filenamesFromToc =>
    checkForUnlistedFiles(filenamesFromToc, true)
  )
  // Write a _toc_autogenerated.yaml to record what files were created.
  .then(htmlFiles => writeGeneratedFileList(htmlFiles))
  // Correct the links in all the generated html files now that files have
  // all been moved to top level.
  .then(fixAllLinks)
  // Add local variable include line to index.html (to access current SDK
  // version number).
  .then(() => addThirdPartyTypeAliases(
    generateThirdPartyHeader('@google-cloud/firestore'),
    thirdPartyFooter,
    firestoreHtmlPath,
    '_firestore.',
    'https://googleapis.dev/nodejs/firestore/latest/',
    firestoreExcludes,
  ))
  .then(() => removeAllNonTopLevelContent(databaseHtmlPath))
  .then(() => addThirdPartyTypeAliases(
    generateThirdPartyHeader('@firebase/database-types'),
    thirdPartyFooter,
    databaseHtmlPath,
    '_database.',
    'https://firebase.google.com/docs/reference/js/firebase.database.',
    databaseExcludes
  ))
  .then(addPageTitleNamespace)
  .then(() => {
    fs.readFile(`${docPath}/index.html`, 'utf8').then(data => {
      // String to include devsite local variables.
      const localVariablesIncludeString = `{% include "docs/web/_local_variables.html" %}\n`;
      return fs.writeFile(
        `${docPath}/index.html`,
        localVariablesIncludeString + data
      );
    });
  })
  .catch(e => {
    if (e.stdout) {
      console.error(e.stdout);
    } else {
      console.error(e);
    }
  });
